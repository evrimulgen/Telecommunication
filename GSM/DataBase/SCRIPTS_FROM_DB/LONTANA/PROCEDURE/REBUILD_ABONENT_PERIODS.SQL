
  CREATE OR REPLACE PROCEDURE "LONTANA"."REBUILD_ABONENT_PERIODS" (
  pYEAR_MONTH IN INTEGER, 
  pPHONE_NUMBER IN VARCHAR2
  ) IS
  CURSOR C IS
    SELECT H.PHONE_NUMBER, 
           NVL(H.PHONE_IS_ACTIVE, 0) IS_ACTIVE, 
           TRUNC(H.BEGIN_DATE) BEGIN_DATE,
           TRUNC(H.END_DATE) END_DATE,
           H.CELL_PLAN_CODE TARIFF_CODE, 
           H.BEGIN_DATE + (H.END_DATE - H.BEGIN_DATE)/2 CHECK_DATE,
           H.BEGIN_DATE REAL_BEGIN_DATE, 
           H.END_DATE REAL_END_DATE
      FROM DB_LOADER_ACCOUNT_PHONE_HISTS H      
      WHERE H.PHONE_NUMBER = pPHONE_NUMBER
        AND TRUNC(H.BEGIN_DATE) <= LAST_DAY(TO_DATE(pYEAR_MONTH, 'YYYYMM'))
        AND TRUNC(H.END_DATE) >= TO_DATE(pYEAR_MONTH, 'YYYYMM')
      ORDER BY H.BEGIN_DATE DESC;
  CURSOR D(pBEGIN IN DATE, pEND IN DATE) IS
    SELECT *
      FROM QUEUE_PHONE_REBLOCK_LOG Q
      WHERE Q.PHONE_NUMBER = pPHONE_NUMBER
        AND Q.TICKED_UNLOCK_ID IS NOT NULL
        AND Q.DATE_UNLOCK >= pBEGIN - 1/24
        AND Q.DATE_UNLOCK <= pEND;
  vDUMMY C%ROWTYPE;
  vD_DUMMY D%ROWTYPE;
  vDATE_BEGIN DATE;
  vDATE_END DATE;
  vDATE_CHECK DATE;
  vPREV_STATE INTEGER;
  vLAST INTEGER;
  vBEGIN DATE;
  vEND DATE;
  vTARIFF_ID INTEGER;
BEGIN
  NULL;
  -- Очищение данных
  delete DB_LOADER_ABONENT_PERIODS db
    where db.YEAR_MONTH = pYEAR_MONTH
      and db.PHONE_NUMBER = pPHONE_NUMBER;
  -- Заполнение обновленными данными
  vDATE_BEGIN:=TO_DATE(pYEAR_MONTH, 'YYYYMM');
  vDATE_END:=LAST_DAY(vDATE_BEGIN);
  vDATE_CHECK:=vDATE_END+1;
  vPREV_STATE:=0;
  vLAST:=0;
  OPEN C;
  FETCH C INTO vDUMMY;
  IF C%FOUND THEN
    LOOP
      -- Тело цикла
      -- Определение границ по статусу
    /*  IF vPREV_STATE = 1 THEN
        vDUMMY.END_DATE:=vDUMMY.END_DATE-1;
      END IF;      */
      IF vDUMMY.IS_ACTIVE = 0  THEN
        vDUMMY.BEGIN_DATE:=vDUMMY.BEGIN_DATE+1;
      END IF;
      IF (vDUMMY.IS_ACTIVE = 1) AND (vDUMMY.END_DATE >= vDATE_CHECK) AND (vPREV_STATE = 1) THEN
        vDUMMY.END_DATE:=vDUMMY.END_DATE - 1;
      END IF;
      -- Проверка границ периода
      IF vDUMMY.BEGIN_DATE < vDATE_BEGIN THEN
        vDUMMY.BEGIN_DATE := vDATE_BEGIN;
        vLAST:=1;
      END IF;
      IF vDUMMY.END_DATE > vDATE_END THEN
        vDUMMY.END_DATE := vDATE_END;
      END IF;
      IF TRUNC(vDUMMY.CHECK_DATE) > vDUMMY.END_DATE THEN
        IF vDUMMY.END_DATE = vDUMMY.BEGIN_DATE THEN
          -- вЫБРАННЫЙ ПЕРИОД В ОДИН ДЕНЬ И ИМЕЕТ НАЧАЛО - КОНЕЦ В ВИДЕ ДАТЫ БЕЗ ВРЕМЕНИ
          vDUMMY.CHECK_DATE := vDUMMY.END_DATE + 1 - 5/24/60;  
        ELSE
          vDUMMY.CHECK_DATE := vDUMMY.END_DATE - 5/24/60;
        END IF;
      END IF;
      /*  IF vDUMMY.END_DATE < vDATE_CHECK THEN
          -- Вычисление отрезка                  
          vDATE_CHECK:=vDUMMY.END_DATE;
        END IF;*/
      IF (vDUMMY.IS_ACTIVE = 1) 
          AND (vDUMMY.REAL_END_DATE < vDUMMY.REAL_BEGIN_DATE + 3/24 ) THEN
        OPEN D(vDUMMY.REAL_BEGIN_DATE, vDUMMY.REAL_END_DATE);
        FETCH D INTO vD_DUMMY;
        IF D%FOUND THEN
          vDUMMY.IS_ACTIVE:=0;
        END IF;
        CLOSE D;
      END IF;
      IF (vDUMMY.BEGIN_DATE <= vDUMMY.END_DATE) AND (vDUMMY.END_DATE < vDATE_CHECK) THEN
        vTARIFF_ID:=GET_PHONE_TARIFF_ID(pPHONE_NUMBER, vDUMMY.TARIFF_CODE, vDUMMY.CHECK_DATE);
        INSERT INTO DB_LOADER_ABONENT_PERIODS(YEAR_MONTH, PHONE_NUMBER, BEGIN_DATE, END_DATE, TARIFF_CODE, TARIFF_ID, IS_ACTIVE, CHECK_DATE)
          VALUES(pYEAR_MONTH, pPHONE_NUMBER, vDUMMY.BEGIN_DATE, vDUMMY.END_DATE, vDUMMY.TARIFF_CODE, vTARIFF_ID, vDUMMY.IS_ACTIVE, vDUMMY.CHECK_DATE);
        /*IF (vDUMMY.IS_ACTIVE = 0) AND (vDATE_CHECK > vDUMMY.BEGIN_DATE + 1) THEN  
          vDATE_CHECK:=vDUMMY.BEGIN_DATE + 1;*/
--        ELSE
          vDATE_CHECK:=vDUMMY.BEGIN_DATE;
--        END IF;
        vPREV_STATE:=vDUMMY.IS_ACTIVE;
      END IF;
      -- Выход из цикла
      FETCH C INTO vDUMMY;
      EXIT WHEN C%NOTFOUND;
    END LOOP;
  END IF;
  CLOSE C;
  -- Сохранение
  COMMIT;
END; 