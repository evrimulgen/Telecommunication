--
-- Create Schema Script 
--   Database Version   : 10.2.0.1.0 
--   TOAD Version       : 9.1.0.62 
--   DB Connect String  : XE 
--   Schema             : LONTANA 
--   Script Created by  : LONTANA 
--   Script Created at  : 21.11.2010 19:07:29 
--   Physical Location  :  
--   Notes              :  
--

-- Object Counts: 
--   Functions: 16      Lines of Code: 144 
--   Indexes: 47        Columns: 47         
--   Packages: 1        Lines of Code: 45 
--   Package Bodies: 1  Lines of Code: 129 
--   Procedures: 5      Lines of Code: 80 
--   Sequences: 15 
--   Tables: 17         Columns: 162        Constraints: 36     
--   Triggers: 17 
--   Views: 2           


CREATE SEQUENCE S_NEW_CONTRACT_CANCEL_TYPE_ID
  START WITH 21
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE S_NEW_CONTRACT_CANCEL_ID
  START WITH 41
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE S_NEW_CONTRACT_CHANGE_ID
  START WITH 41
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE S_NEW_OPERATOR_ID
  START WITH 21
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE S_NEW_COUNTRY_ID
  START WITH 41
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE S_NEW_REGION_ID
  START WITH 21
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE S_NEW_PHONE_BLOCK_ID
  START WITH 1
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE S_NEW_SERVICE_ID
  START WITH 21
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE S_NEW_ABONENT_ID
  START WITH 61
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE S_NEW_FILIAL_ID
  START WITH 61
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE S_NEW_USER_NAME_ID
  START WITH 41
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE SEQUENCE S_NEW_DOCUM_TYPE_ID
  START WITH 41
  MAXVALUE 999999999999999999999999999
  MINVALUE 1
  NOCYCLE
  CACHE 20
  NOORDER;


CREATE TABLE OPERATORS
(
  OPERATOR_ID        INTEGER                    NOT NULL,
  OPERATOR_NAME      VARCHAR2(100 CHAR),
  ORDER_NUMBER       NUMBER(4, 0),
  LOADER_SCRIPT_NAME VARCHAR2(30 CHAR),
  USER_CREATED       VARCHAR2(30 CHAR),
  DATE_CREATED       DATE,
  USER_LAST_UPDATED  VARCHAR2(30 CHAR),
  DATE_LAST_UPDATED  DATE
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;

COMMENT ON TABLE OPERATORS IS 'Операторы сотовой связи';

COMMENT ON COLUMN OPERATORS.OPERATOR_ID IS 'Первичный ключ';

COMMENT ON COLUMN OPERATORS.OPERATOR_NAME IS 'Наименование оператора сотовой связи';

COMMENT ON COLUMN OPERATORS.ORDER_NUMBER IS 'Порядковый номер';

COMMENT ON COLUMN OPERATORS.LOADER_SCRIPT_NAME IS 'Имя скрипта загрузки детализаций';

COMMENT ON COLUMN OPERATORS.USER_CREATED IS 'Пользователь, создавший запись';

COMMENT ON COLUMN OPERATORS.DATE_CREATED IS 'Дата/время создания записи';

COMMENT ON COLUMN OPERATORS.USER_LAST_UPDATED IS 'Пользователь, редактировавший запись последним';

COMMENT ON COLUMN OPERATORS.DATE_LAST_UPDATED IS 'Дата/время последней редакции записи';


CREATE TABLE COUNTRIES
(
  COUNTRY_ID         INTEGER                    NOT NULL,
  COUNTRY_NAME       VARCHAR2(100 CHAR),
  USER_CREATED       VARCHAR2(30 CHAR),
  DATE_CREATED       DATE,
  USER_LAST_UPDATED  VARCHAR2(30 CHAR),
  DATE_LAST_UPDATED  DATE,
  IS_DEFAULT         NUMBER(1)
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;

COMMENT ON TABLE COUNTRIES IS 'Страны';

COMMENT ON COLUMN COUNTRIES.COUNTRY_ID IS 'Первичный ключ';

COMMENT ON COLUMN COUNTRIES.COUNTRY_NAME IS 'Наименование страны';

COMMENT ON COLUMN COUNTRIES.USER_CREATED IS 'Пользователь, создавший запись';

COMMENT ON COLUMN COUNTRIES.DATE_CREATED IS 'Дата/время создания записи';

COMMENT ON COLUMN COUNTRIES.USER_LAST_UPDATED IS 'Пользователь, редактировавший запись последним';

COMMENT ON COLUMN COUNTRIES.DATE_LAST_UPDATED IS 'Дата/время последней редакции записи';

COMMENT ON COLUMN COUNTRIES.IS_DEFAULT IS 'Признак - Страна по умолчанию';


CREATE TABLE REGIONS
(
  REGION_ID          INTEGER                    NOT NULL,
  REGION_NAME        VARCHAR2(100 CHAR),
  ORDER_NUMBER       INTEGER,
  IS_DEFAULT         NUMBER(1),
  COUNTRY_ID         INTEGER,
  USER_CREATED       VARCHAR2(30 CHAR),
  DATE_CREATED       DATE,
  USER_LAST_UPDATED  VARCHAR2(30 CHAR),
  DATE_LAST_UPDATED  DATE
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;

COMMENT ON COLUMN REGIONS.REGION_ID IS 'Первичный ключ';

COMMENT ON COLUMN REGIONS.REGION_NAME IS 'Наименование региона';

COMMENT ON COLUMN REGIONS.ORDER_NUMBER IS 'Порядковый номер сортировки';

COMMENT ON COLUMN REGIONS.IS_DEFAULT IS 'Признак "По умолчанию"';

COMMENT ON COLUMN REGIONS.COUNTRY_ID IS 'Код страны, к которой находится регион';

COMMENT ON COLUMN REGIONS.USER_CREATED IS 'Пользователь, создавший запись';

COMMENT ON COLUMN REGIONS.DATE_CREATED IS 'Дата/время создания записи';

COMMENT ON COLUMN REGIONS.USER_LAST_UPDATED IS 'Пользователь, редактировавший запись последним';

COMMENT ON COLUMN REGIONS.DATE_LAST_UPDATED IS 'Дата/время последней редакции записи';


CREATE TABLE DOCUM_TYPES
(
  DOCUM_TYPE_ID      INTEGER                    NOT NULL,
  DOCUM_TYPE_NAME    VARCHAR2(100 CHAR),
  USER_CREATED       VARCHAR2(30 CHAR),
  DATE_CREATED       DATE,
  USER_LAST_UPDATED  VARCHAR2(30 CHAR),
  DATE_LAST_UPDATED  DATE
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;

COMMENT ON TABLE DOCUM_TYPES IS 'Типы документов';

COMMENT ON COLUMN DOCUM_TYPES.DOCUM_TYPE_ID IS 'Первичный ключ';

COMMENT ON COLUMN DOCUM_TYPES.DOCUM_TYPE_NAME IS 'Наименование ';

COMMENT ON COLUMN DOCUM_TYPES.USER_CREATED IS 'Пользователь, создавший запись';

COMMENT ON COLUMN DOCUM_TYPES.DATE_CREATED IS 'Дата/время создания записи';

COMMENT ON COLUMN DOCUM_TYPES.USER_LAST_UPDATED IS 'Пользователь, редактировавший запись последним';

COMMENT ON COLUMN DOCUM_TYPES.DATE_LAST_UPDATED IS 'Дата/время последней редакции записи';

SET DEFINE OFF;
Insert into DOCUM_TYPES
   (DOCUM_TYPE_ID, DOCUM_TYPE_NAME)
 Values
   (1, 'Договор аренды номера');
Insert into DOCUM_TYPES
   (DOCUM_TYPE_ID, DOCUM_TYPE_NAME)
 Values
   (2, 'Заявление об утере Сим-карты');
Insert into DOCUM_TYPES
   (DOCUM_TYPE_ID, DOCUM_TYPE_NAME)
 Values
   (3, 'Заявление о смене номера телефона');
Insert into DOCUM_TYPES
   (DOCUM_TYPE_ID, DOCUM_TYPE_NAME)
 Values
   (4, 'Заявление на смену тарифного плана');
Insert into DOCUM_TYPES
   (DOCUM_TYPE_ID, DOCUM_TYPE_NAME)
 Values
   (5, 'Заявление на расторжение договора');
Insert into DOCUM_TYPES
   (DOCUM_TYPE_ID, DOCUM_TYPE_NAME)
 Values
   (0, 'Оплата');
COMMIT;


CREATE TABLE FILIALS
(
  FILIAL_ID          INTEGER                    NOT NULL,
  FILIAL_NAME        VARCHAR2(100 CHAR),
  USER_CREATED       VARCHAR2(30 CHAR),
  DATE_CREATED       DATE,
  USER_LAST_UPDATED  VARCHAR2(30 CHAR),
  DATE_LAST_UPDATED  DATE
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;

COMMENT ON TABLE FILIALS IS 'Филиалы и офисы организации';

COMMENT ON COLUMN FILIALS.FILIAL_ID IS 'Первичный ключ';

COMMENT ON COLUMN FILIALS.FILIAL_NAME IS 'Наименование ';

COMMENT ON COLUMN FILIALS.USER_CREATED IS 'Пользователь, создавший запись';

COMMENT ON COLUMN FILIALS.DATE_CREATED IS 'Дата/время создания записи';

COMMENT ON COLUMN FILIALS.USER_LAST_UPDATED IS 'Пользователь, редактировавший запись последним';

COMMENT ON COLUMN FILIALS.DATE_LAST_UPDATED IS 'Дата/время последней редакции записи';


CREATE TABLE PHONE_BLOCKS
(
  PHONE_BLOCK_ID      INTEGER                   NOT NULL,
  OPERATOR_ID         INTEGER,
  PHONE_NUMBER_BEGIN  VARCHAR2(20 CHAR),
  PHONE_NUMBER_END    VARCHAR2(20 CHAR),
  USER_CREATED        VARCHAR2(30 CHAR),
  DATE_CREATED        DATE,
  USER_LAST_UPDATED   VARCHAR2(30 CHAR),
  DATE_LAST_UPDATED   DATE
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;

COMMENT ON TABLE PHONE_BLOCKS IS 'Блоки телефонных номеров';

COMMENT ON COLUMN PHONE_BLOCKS.PHONE_BLOCK_ID IS 'Первичный ключ';

COMMENT ON COLUMN PHONE_BLOCKS.OPERATOR_ID IS 'Код оператора сотовой связи';

COMMENT ON COLUMN PHONE_BLOCKS.PHONE_NUMBER_BEGIN IS 'Начальный номер блока';

COMMENT ON COLUMN PHONE_BLOCKS.PHONE_NUMBER_END IS 'Конечный номер блока (включительно)';

COMMENT ON COLUMN PHONE_BLOCKS.USER_CREATED IS 'Пользователь, создавший запись';

COMMENT ON COLUMN PHONE_BLOCKS.DATE_CREATED IS 'Дата/время создания записи';

COMMENT ON COLUMN PHONE_BLOCKS.USER_LAST_UPDATED IS 'Пользователь, редактировавший запись последним';

COMMENT ON COLUMN PHONE_BLOCKS.DATE_LAST_UPDATED IS 'Дата/время последней редакции записи';


CREATE TABLE SERVICES
(
  SERVICE_ID         INTEGER                    NOT NULL,
  SERVICE_NAME       VARCHAR2(100 CHAR),
  PRICE              NUMBER,
  USER_CREATED       VARCHAR2(30 CHAR),
  DATE_CREATED       DATE,
  USER_LAST_UPDATED  VARCHAR2(30 CHAR),
  DATE_LAST_UPDATED  DATE
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;

COMMENT ON TABLE SERVICES IS 'Услуги выбора номера';

COMMENT ON COLUMN SERVICES.SERVICE_ID IS 'Первичный ключ';

COMMENT ON COLUMN SERVICES.SERVICE_NAME IS 'Наименование услуги';

COMMENT ON COLUMN SERVICES.PRICE IS 'Стоимость услуги';

COMMENT ON COLUMN SERVICES.USER_CREATED IS 'Пользователь, создавший запись';

COMMENT ON COLUMN SERVICES.DATE_CREATED IS 'Дата/время создания записи';

COMMENT ON COLUMN SERVICES.USER_LAST_UPDATED IS 'Пользователь, редактировавший запись последним';

COMMENT ON COLUMN SERVICES.DATE_LAST_UPDATED IS 'Дата/время последней редакции записи';


CREATE TABLE ABONENTS
(
  ABONENT_ID         INTEGER                    NOT NULL,
  SURNAME            VARCHAR2(30 CHAR)          NOT NULL,
  NAME               VARCHAR2(30 CHAR)          NOT NULL,
  PATRONYMIC         VARCHAR2(30 CHAR),
  BDATE              DATE,
  PASSPORT_SER       VARCHAR2(10 CHAR),
  PASSPORT_NUM       VARCHAR2(10 CHAR),
  PASSPORT_DATE      DATE,
  PASSPORT_GET       VARCHAR2(50 CHAR),
  CITIZENSHIP        INTEGER,
  COUNTRY_ID         INTEGER,
  REGION_ID          INTEGER,
  REGION_NAME        VARCHAR2(100 CHAR),
  CITY_NAME          VARCHAR2(30 CHAR),
  STREET_NAME        VARCHAR2(30 CHAR),
  HOUSE              VARCHAR2(10 CHAR),
  KORPUS             VARCHAR2(10 CHAR),
  APARTMENT          VARCHAR2(10 CHAR),
  CONTACT_INFO       VARCHAR2(100 CHAR),
  CODE_WORD          VARCHAR2(50 CHAR),
  IS_VIP             NUMBER(1),
  EMAIL              VARCHAR2(100),
  USER_CREATED       VARCHAR2(30 CHAR),
  DATE_CREATED       DATE,
  USER_LAST_UPDATED  VARCHAR2(30 CHAR),
  DATE_LAST_UPDATED  DATE
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;

COMMENT ON TABLE ABONENTS IS 'Абоненты';

COMMENT ON COLUMN ABONENTS.ABONENT_ID IS 'Первичный ключ';

COMMENT ON COLUMN ABONENTS.SURNAME IS 'Фамилия';

COMMENT ON COLUMN ABONENTS.NAME IS 'Имя';

COMMENT ON COLUMN ABONENTS.PATRONYMIC IS 'Отчество';

COMMENT ON COLUMN ABONENTS.BDATE IS 'Дата рождения';

COMMENT ON COLUMN ABONENTS.PASSPORT_SER IS 'Серия паспорта';

COMMENT ON COLUMN ABONENTS.PASSPORT_NUM IS 'Номер паспорта';

COMMENT ON COLUMN ABONENTS.PASSPORT_DATE IS 'Дата выдачи паспорта';

COMMENT ON COLUMN ABONENTS.PASSPORT_GET IS 'Кем выдан паспорт';

COMMENT ON COLUMN ABONENTS.CITIZENSHIP IS 'Гражданство (код страны из справочника стран)';

COMMENT ON COLUMN ABONENTS.COUNTRY_ID IS 'Прописка: Страна (код страны из справочника стран)';

COMMENT ON COLUMN ABONENTS.REGION_ID IS 'Прописка: Регион (код региона из справочника регионов)';

COMMENT ON COLUMN ABONENTS.REGION_NAME IS 'Прописка: Наименование региона';

COMMENT ON COLUMN ABONENTS.CITY_NAME IS 'Прописка: Город';

COMMENT ON COLUMN ABONENTS.STREET_NAME IS 'Прописка: Улица';

COMMENT ON COLUMN ABONENTS.HOUSE IS 'Прописка: Дом';

COMMENT ON COLUMN ABONENTS.KORPUS IS 'Прописка: Корпус';

COMMENT ON COLUMN ABONENTS.APARTMENT IS 'Прописка: Квартира';

COMMENT ON COLUMN ABONENTS.CONTACT_INFO IS 'Контактная информация (строка; телефоны в произвольном виде)';

COMMENT ON COLUMN ABONENTS.CODE_WORD IS 'Кодовое слово';

COMMENT ON COLUMN ABONENTS.IS_VIP IS 'Признак VIP клиента';

COMMENT ON COLUMN ABONENTS.EMAIL IS 'E-mail абонента';

COMMENT ON COLUMN ABONENTS.USER_CREATED IS 'Пользователь, создавший запись';

COMMENT ON COLUMN ABONENTS.DATE_CREATED IS 'Дата/время создания записи';

COMMENT ON COLUMN ABONENTS.USER_LAST_UPDATED IS 'Пользователь, редактировавший запись последним';

COMMENT ON COLUMN ABONENTS.DATE_LAST_UPDATED IS 'Дата/время последней редакции записи';


CREATE TABLE CONTRACT_CANCEL_TYPES
(
  CONTRACT_CANCEL_TYPE_ID    INTEGER            NOT NULL,
  CONTRACT_CANCEL_TYPE_NAME  VARCHAR2(100 CHAR),
  USER_CREATED               VARCHAR2(30 CHAR),
  DATE_CREATED               DATE,
  USER_LAST_UPDATED          VARCHAR2(30 CHAR),
  DATE_LAST_UPDATED          DATE
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;

COMMENT ON TABLE CONTRACT_CANCEL_TYPES IS 'Причины расторжения договора';

COMMENT ON COLUMN CONTRACT_CANCEL_TYPES.CONTRACT_CANCEL_TYPE_ID IS 'Первичный ключ';

COMMENT ON COLUMN CONTRACT_CANCEL_TYPES.CONTRACT_CANCEL_TYPE_NAME IS 'Наименование ';

COMMENT ON COLUMN CONTRACT_CANCEL_TYPES.USER_CREATED IS 'Пользователь, создавший запись';

COMMENT ON COLUMN CONTRACT_CANCEL_TYPES.DATE_CREATED IS 'Дата/время создания записи';

COMMENT ON COLUMN CONTRACT_CANCEL_TYPES.USER_LAST_UPDATED IS 'Пользователь, редактировавший запись последним';

COMMENT ON COLUMN CONTRACT_CANCEL_TYPES.DATE_LAST_UPDATED IS 'Дата/время последней редакции записи';


CREATE TABLE CONTRACT_CANCELS
(
  CONTRACT_CANCEL_ID       INTEGER              NOT NULL,
  CONTRACT_ID              INTEGER              NOT NULL,
  FILIAL_ID                INTEGER,
  CONTRACT_CANCEL_DATE     DATE                 NOT NULL,
  CONTRACT_CANCEL_TYPE_ID  INTEGER,
  SUM_GET                  NUMBER,
  SUM_PUT                  NUMBER,
  USER_CREATED             VARCHAR2(30 CHAR),
  DATE_CREATED             DATE,
  USER_LAST_UPDATED        VARCHAR2(30 CHAR),
  DATE_LAST_UPDATED        DATE,
  CONFIRMED                NUMBER(1)
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;

COMMENT ON TABLE CONTRACT_CANCELS IS 'Расторжения тоговоров';

COMMENT ON COLUMN CONTRACT_CANCELS.CONTRACT_CANCEL_ID IS 'Первичный ключ';

COMMENT ON COLUMN CONTRACT_CANCELS.CONTRACT_ID IS 'Код контракта';

COMMENT ON COLUMN CONTRACT_CANCELS.FILIAL_ID IS 'Код филиала';

COMMENT ON COLUMN CONTRACT_CANCELS.CONTRACT_CANCEL_DATE IS 'Дата расторжения контракта';

COMMENT ON COLUMN CONTRACT_CANCELS.CONTRACT_CANCEL_TYPE_ID IS 'Код причины расторжения договора';

COMMENT ON COLUMN CONTRACT_CANCELS.SUM_GET IS 'Сумма полученная от клиента';

COMMENT ON COLUMN CONTRACT_CANCELS.SUM_PUT IS 'Сумма выплаченная клиенту';

COMMENT ON COLUMN CONTRACT_CANCELS.USER_CREATED IS 'Пользователь, создавший запись';

COMMENT ON COLUMN CONTRACT_CANCELS.DATE_CREATED IS 'Дата/время создания записи';

COMMENT ON COLUMN CONTRACT_CANCELS.USER_LAST_UPDATED IS 'Пользователь, редактировавший запись последним';

COMMENT ON COLUMN CONTRACT_CANCELS.DATE_LAST_UPDATED IS 'Дата/время последней редакции записи';

COMMENT ON COLUMN CONTRACT_CANCELS.CONFIRMED IS '1 - документ проведен';


CREATE TABLE CONTRACT_CHANGES
(
  CONTRACT_CHANGE_ID    INTEGER                 NOT NULL,
  CONTRACT_ID           INTEGER                 NOT NULL,
  FILIAL_ID             INTEGER                 NOT NULL,
  CONTRACT_CHANGE_DATE  DATE                    NOT NULL,
  PHONE_NUMBER_FEDERAL  VARCHAR2(10 CHAR),
  PHONE_NUMBER_CITY     VARCHAR2(7 CHAR),
  PHONE_NUMBER_TYPE     NUMBER(1),
  SIM_NUMBER            VARCHAR2(20 CHAR),
  SUM_GET               NUMBER,
  USER_CREATED          VARCHAR2(30 CHAR),
  DATE_CREATED          DATE,
  USER_LAST_UPDATED     VARCHAR2(30 CHAR),
  DATE_LAST_UPDATED     DATE,
  OPERATOR_ID           INTEGER,
  TARIFF_ID             INTEGER,
  DOCUM_TYPE_ID         INTEGER                 NOT NULL,
  CONFIRMED             NUMBER(1)
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;

COMMENT ON TABLE CONTRACT_CHANGES IS 'Расторжения тоговоров';

COMMENT ON COLUMN CONTRACT_CHANGES.CONTRACT_CHANGE_ID IS 'Первичный ключ';

COMMENT ON COLUMN CONTRACT_CHANGES.CONTRACT_ID IS 'Код контракта';

COMMENT ON COLUMN CONTRACT_CHANGES.FILIAL_ID IS 'Код филиала';

COMMENT ON COLUMN CONTRACT_CHANGES.CONTRACT_CHANGE_DATE IS 'Дата изменения контракта';

COMMENT ON COLUMN CONTRACT_CHANGES.PHONE_NUMBER_FEDERAL IS '№ телефона в федеральном формате (строго 10 цифр)';

COMMENT ON COLUMN CONTRACT_CHANGES.PHONE_NUMBER_CITY IS '№ телефона в городском формате (7 цифр)';

COMMENT ON COLUMN CONTRACT_CHANGES.PHONE_NUMBER_TYPE IS 'Вид номера (1- городской, иначе федеральный)';

COMMENT ON COLUMN CONTRACT_CHANGES.SIM_NUMBER IS 'Номер SIM карты';

COMMENT ON COLUMN CONTRACT_CHANGES.SUM_GET IS 'Сумма полученная от клиента';

COMMENT ON COLUMN CONTRACT_CHANGES.USER_CREATED IS 'Пользователь, создавший запись';

COMMENT ON COLUMN CONTRACT_CHANGES.DATE_CREATED IS 'Дата/время создания записи';

COMMENT ON COLUMN CONTRACT_CHANGES.USER_LAST_UPDATED IS 'Пользователь, редактировавший запись последним';

COMMENT ON COLUMN CONTRACT_CHANGES.DATE_LAST_UPDATED IS 'Дата/время последней редакции записи';

COMMENT ON COLUMN CONTRACT_CHANGES.TARIFF_ID IS 'Код тарифного плана';

COMMENT ON COLUMN CONTRACT_CHANGES.OPERATOR_ID IS 'Код оператора';

COMMENT ON COLUMN CONTRACT_CHANGES.DOCUM_TYPE_ID IS 'Код типа документа (какой вид изменения договора)';

COMMENT ON COLUMN CONTRACT_CHANGES.CONFIRMED IS '1 - документ проведен';


CREATE TABLE AUTO_NUMERATION2_FREE_VALUES
(
  SEQUENCE_NAME  VARCHAR2(100 BYTE),
  VALUE          INTEGER
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;

COMMENT ON TABLE AUTO_NUMERATION2_FREE_VALUES IS 'Незанятые (свободные) номера для автонумерации документов.
Строки, номера которых выданы, но транзакция не завершилась, заблокированы,
и при завершении транзакции автоматически удаляются, а при откате транзакции разблокируются.';

COMMENT ON COLUMN AUTO_NUMERATION2_FREE_VALUES.SEQUENCE_NAME IS 'Логическое наименование последовательности';

COMMENT ON COLUMN AUTO_NUMERATION2_FREE_VALUES.VALUE IS 'Значение номера';


CREATE TABLE AUTO_NUMERATION2_SEQUENCES
(
  SEQUENCE_NAME  VARCHAR2(100 BYTE),
  LAST_VALUE     INTEGER
)
LOGGING 
NOCOMPRESS 
NOCACHE
NOPARALLEL
MONITORING;

COMMENT ON TABLE AUTO_NUMERATION2_SEQUENCES IS 'Справочник последовательностей для системы автонумерации документов';

COMMENT ON COLUMN AUTO_NUMERATION2_SEQUENCES.SEQUENCE_NAME IS 'Логическое наименование последовательности (уникальное)';

COMMENT ON COLUMN AUTO_NUMERATION2_SEQUENCES.LAST_VALUE IS 'Последнее выданное значение последовательности';


CREATE INDEX I_CONTRACT_CHANGES_DOC_TYPE_ID ON CONTRACT_CHANGES
(DOCUM_TYPE_ID)
LOGGING
NOPARALLEL;


CREATE INDEX I_CONTRACT_CHANGES_CONTRACT_ID ON CONTRACT_CHANGES
(CONTRACT_ID)
LOGGING
NOPARALLEL;


CREATE INDEX I_CONTRACT_CHANGES_TARIFF_ID ON CONTRACT_CHANGES
(TARIFF_ID)
LOGGING
NOPARALLEL;


CREATE INDEX I_CONTRACT_CHANGES_OPERATOR_ID ON CONTRACT_CHANGES
(OPERATOR_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_AUTO_NUMERATION2_SEQUENCES ON AUTO_NUMERATION2_SEQUENCES
(SEQUENCE_NAME)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_FILIALS ON FILIALS
(FILIAL_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_DOCUM_TYPES ON DOCUM_TYPES
(DOCUM_TYPE_ID)
LOGGING
NOPARALLEL;


CREATE INDEX I_ABONENTS_HOUSE ON ABONENTS
(HOUSE)
LOGGING
NOPARALLEL;


CREATE INDEX I_ABONENTS_STREET_NAME ON ABONENTS
(STREET_NAME)
LOGGING
NOPARALLEL;


CREATE INDEX I_ABONENTS_CITY_NAME ON ABONENTS
(CITY_NAME)
LOGGING
NOPARALLEL;


CREATE INDEX I_ABONENTS_BDATE ON ABONENTS
(BDATE)
LOGGING
NOPARALLEL;


CREATE INDEX I_ABONENTS_PATRONYMIC ON ABONENTS
(PATRONYMIC)
LOGGING
NOPARALLEL;


CREATE INDEX I_ABONENTS_NAME ON ABONENTS
(NAME)
LOGGING
NOPARALLEL;


CREATE INDEX I_ABONENTS_SURNAME ON ABONENTS
(SURNAME)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_CONTRACTS ON CONTRACTS
(CONTRACT_ID)
LOGGING
NOPARALLEL;


CREATE INDEX I_ABONENTS_REGION_ID ON ABONENTS
(REGION_ID)
LOGGING
NOPARALLEL;


CREATE INDEX I_ABONENTS_COUNTRY_ID ON ABONENTS
(COUNTRY_ID)
LOGGING
NOPARALLEL;


CREATE INDEX I_ABONENTS_CITIZENSHIP ON ABONENTS
(CITIZENSHIP)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_ABONENTS ON ABONENTS
(ABONENT_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_SERVICES ON SERVICES
(SERVICE_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_PHONE_BLOCKS ON PHONE_BLOCKS
(PHONE_BLOCK_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_COUNTRIES ON COUNTRIES
(COUNTRY_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_OPERATORS ON OPERATORS
(OPERATOR_ID)
LOGGING
NOPARALLEL;


CREATE INDEX I_REGIONS_COUNTRY_ID ON REGIONS
(COUNTRY_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_REGIONS ON REGIONS
(REGION_ID)
LOGGING
NOPARALLEL;


CREATE INDEX I_CONTRACT_CHANGES_FILIAL_ID ON CONTRACT_CHANGES
(FILIAL_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_CONTRACT_CHANGES ON CONTRACT_CHANGES
(CONTRACT_CHANGE_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX I_CONTRACT_CANCELS_CONTRACT_ID ON CONTRACT_CANCELS
(CONTRACT_ID)
LOGGING
NOPARALLEL;


CREATE INDEX I_CONTRACT_CANCELS_TYPE_ID ON CONTRACT_CANCELS
(CONTRACT_CANCEL_TYPE_ID)
LOGGING
NOPARALLEL;


CREATE INDEX I_CONTRACT_CANCELS_FILIAL_ID ON CONTRACT_CANCELS
(FILIAL_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_CONTRACT_CANCELS ON CONTRACT_CANCELS
(CONTRACT_CANCEL_ID)
LOGGING
NOPARALLEL;


CREATE UNIQUE INDEX PK_CONTRACT_CANCEL_TYPES ON CONTRACT_CANCEL_TYPES
(CONTRACT_CANCEL_TYPE_ID)
LOGGING
NOPARALLEL;


CREATE OR REPLACE PACKAGE AUTO_NUMERATION2 IS 
-- 
--#Version=3 
-- 
-- 3. Уколов. Добавил параметр pFIND_SQL в функцию GET_NEXT_SEQUENCE_VALUE
-- 2. Уколов. Добавил процедуру освобождения номера FREE_SEQUENCE_VALUE
--
-- Пакет позволяет получать последовательности номеров "без пропусков". 
-- 
-- Правила использования:
-- 1. Для правильной работы алгоритма необходимо вызов функции GET_NEXT_SEQUENCE_VALUE 
--    и последующее сохранение документа делать в одной и той же транзакции. 
--    Выполнение COMMIT (явное или неявное) после вызова функции подтверждает 
--    использование номера, а вызов ROLLBACK возвращает номер в список свободных  
--    номеров для повторного использования.
-- 
-- 2. В качестве параметра в функцию GET_NEXT_SEQUENCE_VALUE передается имя последовательности.  
--    Чтобы нумерация шла с начала года, то необходимо включить в  
--    имя последовательности номер года, а чтобы нумерация ежедневно начиналась с 1,  
--    нужно включить в имя последовательности дату. 
--    Примеры имени последовательности: 'НОМЕР_МЕДКАРТЫ_2007', '№_БИОМАТ_123_45_20070801'.
--    Второй параметр - текст SQL-запроса, который проверяет наличие дубликатов номера в таблице
--    и при их обнаружении считает номер занятым и получает следующий номер.
--
-- Функция возвращает номер из последовательности с именем pSEQUENCE_NAME
-- Если позже будет выполнен ROLLBACK, то номер автоматически попадет
-- в список "свободных" номеров и может быть выдан повторно.
--
FUNCTION GET_NEXT_SEQUENCE_VALUE(
  -- Имя последовательности
  pSEQUENCE_NAME IN VARCHAR2, 
  -- Текст SQL-запроса для проверки уникальности (можно не указывать, тогда проверка не выполняется).
  -- Чтобы сослаться на номер, используйте переменную :NUM. 
  -- например: SELECT 1 FROM DOCUMS WHERE DOC_NUM=RPAD(:NUM, 1, 6) -- дополняем нулями до 6 знаков
  pFIND_SQL IN VARCHAR2 DEFAULT NULL
  --
  ) RETURN INTEGER;
--
-- Функция освобождает ранее взятый номер для последовательности pSEQUENCE_NAME.
--
PROCEDURE FREE_SEQUENCE_VALUE(
  pSEQUENCE_NAME IN VARCHAR2,
  pVALUE IN NUMBER);
--
END AUTO_NUMERATION2;
/

SHOW ERRORS;


CREATE OR REPLACE PACKAGE BODY AUTO_NUMERATION2 IS 
-- 
PROCEDURE ADD_VALUE_FROM_SEQUENCE( 
  pSEQUENCE_NAME IN VARCHAR2 
  ) IS 
  PRAGMA AUTONOMOUS_TRANSACTION; 
  vRESULT PLS_INTEGER; 
BEGIN 
  -- Обновляем справочник последовательностей  
  -- (должна быть только одна запись или ни одной) 
  -- и получаем новое значение 
  -- Автономная транзакция должна гарантировать быстрое выполнение процедуры и 
  UPDATE AUTO_NUMERATION2_SEQUENCES 
    SET LAST_VALUE = NVL(LAST_VALUE, 0)+1 
    WHERE SEQUENCE_NAME=pSEQUENCE_NAME 
    RETURNING LAST_VALUE INTO vRESULT; 
  IF vRESULT IS NULL THEN 
    -- Нет записи в справочнике последовательностей 
    -- Добавляем запись 
    INSERT INTO AUTO_NUMERATION2_SEQUENCES (SEQUENCE_NAME, LAST_VALUE)  
      VALUES (pSEQUENCE_NAME, 1); 
    -- Начинаем нумерацию с 1 
    vRESULT := 1; 
  END IF; 
  -- Добавляем значение в пул свободных номеров 
  -- Есть вероятность, что этот номер захватит не наша сессия,  
  -- но это не страшно, так как наша сессия снова ничего не найдет и  
  -- добавит еще один номер.  
  INSERT INTO AUTO_NUMERATION2_FREE_VALUES (SEQUENCE_NAME, VALUE)  
    VALUES (pSEQUENCE_NAME, vRESULT); 
  -- Подтверждаем транзакцию 
  COMMIT; 
END ADD_VALUE_FROM_SEQUENCE; 
-- 
FUNCTION GET_NEXT_SEQUENCE_VALUE( 
  -- Имя последовательности
  pSEQUENCE_NAME IN VARCHAR2, 
  -- Текст SQL-запроса для проверки уникальности (можно не указывать, тогда проверка не выполняется).
  -- Чтобы сослаться на номер, используйте переменную :NUM. 
  -- например: SELECT 1 FROM DOCUMS WHERE DOC_NUM=RPAD(:NUM, 1, 6) -- дополняем нулями до 6 знаков
  pFIND_SQL IN VARCHAR2 DEFAULT NULL
  --
  ) RETURN INTEGER IS 
-- 
  RESOURCE_BUSY  EXCEPTION;          -- Исключение ORA-00054 "RESOURCE_BUSY"       
  PRAGMA EXCEPTION_INIT(RESOURCE_BUSY, -00054);    
-- 
  EMPTY_SEQUENCE_NAME_ERROR CONSTANT PLS_INTEGER := -20387; 
  EMPTY_SEQUENCE_NAME_ERROR_MSG CONSTANT VARCHAR2(44 CHAR) := 'Пустое имя последовательности не допускается'; 
-- 
  vRESULT PLS_INTEGER;
  vCOUNT PLS_INTEGER; 
-- 
BEGIN 
  IF pSEQUENCE_NAME IS NULL THEN 
    RAISE_APPLICATION_ERROR(EMPTY_SEQUENCE_NAME_ERROR, EMPTY_SEQUENCE_NAME_ERROR_MSG); 
  END IF; 
  <<cycle_while_not_found_value>> 
  LOOP -- Цикл 
    -- Перебираем записи в "свободном" пуле 
    <<select_free_pool>> -- Имя цикла 
    FOR rec_free IN ( 
      SELECT F.ROWID FROM AUTO_NUMERATION2_FREE_VALUES F 
        WHERE F.SEQUENCE_NAME=pSEQUENCE_NAME 
        ORDER BY F.VALUE 
      ) LOOP 
      -- Пытаемся заблокировать запись 
      BEGIN 
        -- SELECT ... FOR UPDATE NOWAIT даст исключение RESOURCE_BUSY,  
        -- если запись уже заблокирована другой сессией         
        SELECT F.VALUE  
          INTO vRESULT  
          FROM AUTO_NUMERATION2_FREE_VALUES F 
          WHERE F.ROWID=rec_free.ROWID 
          FOR UPDATE NOWAIT
          ;           
        -- Заблокировать запись удалось, 
        -- Помечаем запись на удаление.  
        -- В этом случае при подтверждении транзакции запись действительно будет удалена, 
        -- а при ROLLBACK удаление откатится, запись станет видимой и незаблокированной  
        -- и будет использована повторно. 
        DELETE FROM AUTO_NUMERATION2_FREE_VALUES F
          WHERE F.ROWID=rec_free.ROWID;
        --
        IF pFIND_SQL IS NULL THEN
          --выходим из цикла 
          -- Блокировка записи будет сохраняться до конца транзакции
          EXIT select_free_pool;
        ELSE 
          -- Проверяем, нет ли записи с таким номером в таблице
          EXECUTE IMMEDIATE
            'SELECT COUNT(*) FROM DUAL WHERE EXISTS ('||pFIND_SQL || ')'
            INTO vCOUNT
            USING IN vRESULT;
          -- Если нет совпадающих записей, выходим из цикла
          EXIT WHEN vCOUNT = 0;
          -- Очищаем результат (он не годится)
          vRESULT := NULL;
        END IF;
      EXCEPTION WHEN RESOURCE_BUSY THEN 
        NULL; -- Ошибка блокировки, возвращаемся в цикл и пробуем следующую запись 
      END; 
    END LOOP select_free_pool; 
    --  
    EXIT cycle_while_not_found_value WHEN vRESULT IS NOT NULL;  
    -- В пуле свободных номеров номер не нашли 
    -- Добавляем номер из последовательности в пул свободных 
    ADD_VALUE_FROM_SEQUENCE(pSEQUENCE_NAME); 
    -- для поиска свободного номера возвращаемся в начало цикла 
  END LOOP cycle_while_not_found_value; 
  RETURN vRESULT; 
END GET_NEXT_SEQUENCE_VALUE;
--
-- Функция освобождает ранее взятый номер для последовательности pSEQUENCE_NAME.
--
PROCEDURE FREE_SEQUENCE_VALUE(
  pSEQUENCE_NAME IN VARCHAR2,
  pVALUE IN NUMBER) IS
BEGIN
  -- Просто добавляем номер в список свободных номеров.
  -- Если транзакция подтвердится, то джобавленный номер увидят все сессии
  -- Если транзакция не подтвердится, добавленнй номер не сохранится.
  -- Если номер освободить и запросить повторно, то получим либо его, либо
  -- другой свободный номер.
  INSERT INTO AUTO_NUMERATION2_FREE_VALUES (SEQUENCE_NAME, VALUE)
    VALUES (pSEQUENCE_NAME, pVALUE);
END FREE_SEQUENCE_VALUE;
--
END AUTO_NUMERATION2;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION NEW_CONTRACT_CANCEL_TYPE_ID RETURN NUMBER IS
--#Version=1
  vRES NUMBER;
BEGIN
  SELECT S_NEW_CONTRACT_CANCEL_TYPE_ID.NEXTVAL
  INTO vRES
  FROM DUAL;
  RETURN vRES;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION NEW_CONTRACT_CANCEL_ID RETURN NUMBER IS
--#Version=1
  vRES NUMBER;
BEGIN
  SELECT S_NEW_CONTRACT_CANCEL_ID.NEXTVAL
  INTO vRES
  FROM DUAL;
  RETURN vRES;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION NEW_CONTRACT_CHANGE_ID RETURN NUMBER IS
--#Version=1
  vRES NUMBER;
BEGIN
  SELECT S_NEW_CONTRACT_CHANGE_ID.NEXTVAL
  INTO vRES
  FROM DUAL;
  RETURN vRES;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION NEW_OPERATOR_ID RETURN NUMBER IS
--#Version=1
  vRES NUMBER;
BEGIN
  SELECT S_NEW_OPERATOR_ID.NEXTVAL
  INTO vRES
  FROM DUAL;
  RETURN vRES;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION NEW_COUNTRY_ID RETURN NUMBER IS
--#Version=1
  vRES NUMBER;
BEGIN
  SELECT S_NEW_COUNTRY_ID.NEXTVAL
  INTO vRES
  FROM DUAL;
  RETURN vRES;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION NEW_REGION_ID RETURN NUMBER IS
--#Version=1
  vRES NUMBER;
BEGIN
  SELECT S_NEW_REGION_ID.NEXTVAL
  INTO vRES
  FROM DUAL;
  RETURN vRES;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION NEW_PHONE_BLOCK_ID RETURN NUMBER IS
--#Version=1
  vRES NUMBER;
BEGIN
  SELECT S_NEW_PHONE_BLOCK_ID.NEXTVAL
  INTO vRES
  FROM DUAL;
  RETURN vRES;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION NEW_ACCOUNT_ID RETURN NUMBER IS
--#Version=1
  vRES NUMBER;
BEGIN
  SELECT S_NEW_ACCOUNT_ID.NEXTVAL
  INTO vRES
  FROM DUAL;
  RETURN vRES;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION NEW_SERVICE_ID RETURN NUMBER IS
--#Version=1
  vRES NUMBER;
BEGIN
  SELECT S_NEW_SERVICE_ID.NEXTVAL
  INTO vRES
  FROM DUAL;
  RETURN vRES;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION NEW_ABONENT_ID RETURN NUMBER IS
--#Version=1
  vRES NUMBER;
BEGIN
  SELECT S_NEW_ABONENT_ID.NEXTVAL
  INTO vRES
  FROM DUAL;
  RETURN vRES;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION NEW_FILIAL_ID RETURN NUMBER IS
--#Version=1
  vRES NUMBER;
BEGIN
  --raise_application_error(-20000, '!');
  SELECT S_NEW_FILIAL_ID.NEXTVAL
  INTO vRES
  FROM DUAL;
  RETURN vRES;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION NEW_USER_NAME_ID RETURN NUMBER IS
--#Version=1
  vRES NUMBER;
BEGIN
  SELECT S_NEW_USER_NAME_ID.NEXTVAL
  INTO vRES
  FROM DUAL;
  RETURN vRES;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION NEW_DOCUM_TYPE_ID RETURN NUMBER IS
--#Version=1
  vRES NUMBER;
BEGIN
  SELECT S_NEW_DOCUM_TYPE_ID.NEXTVAL
  INTO vRES
  FROM DUAL;
  RETURN vRES;
END;
/

SHOW ERRORS;


CREATE OR REPLACE FUNCTION GET_NEXT_CONTRACT_NUMBER RETURN VARCHAR2 IS
--#Version=1
-- Функция возвращает следующий номер договора льготного рецепта, 
-- проверяя его на дублирование.
BEGIN
  RETURN AUTO_NUMERATION2.GET_NEXT_SEQUENCE_VALUE('CONTRACT_NUM', 
    'SELECT 1 FROM CONTRACTS WHERE CONTRACT_NUM=:NUM');
END GET_NEXT_CONTRACT_NUMBER;
/

SHOW ERRORS;


CREATE OR REPLACE VIEW V_CONTRACT_CHANGES
AS 
SELECT MAX(FILIAL_ID) FILIAL_ID,
       MAX(SIM_NUMBER) SIM_NUMBER,
       MAX(PHONE_NUMBER_FEDERAL) PHONE_NUMBER_FEDERAL,
       MAX(PHONE_NUMBER_CITY) PHONE_NUMBER_CITY,
       MAX(PHONE_NUMBER_TYPE) PHONE_NUMBER_TYPE,
       MAX(CONTRACT_CHANGE_DATE) CONTRACT_CHANGE_DATE,
       MAX(TARIFF_ID) TARIFF_ID,
       MAX(OPERATOR_ID) OPERATOR_ID,
       CONTRACT_ID
FROM      
(
SELECT
  FIRST_VALUE(FILIAL_ID) OVER (PARTITION BY CONTRACT_ID ORDER BY DECODE(FILIAL_ID, NULL, 1, 0), CONTRACT_CHANGE_DATE DESC) FILIAL_ID,
  FIRST_VALUE(SIM_NUMBER) OVER (PARTITION BY CONTRACT_ID ORDER BY DECODE(SIM_NUMBER, NULL, 1, 0), CONTRACT_CHANGE_DATE DESC) SIM_NUMBER,
  FIRST_VALUE(PHONE_NUMBER_FEDERAL) OVER (PARTITION BY CONTRACT_ID ORDER BY DECODE(PHONE_NUMBER_FEDERAL, NULL, 1, 0), CONTRACT_CHANGE_DATE DESC) PHONE_NUMBER_FEDERAL,
  FIRST_VALUE(PHONE_NUMBER_CITY) OVER (PARTITION BY CONTRACT_ID ORDER BY DECODE(PHONE_NUMBER_CITY, NULL, 1, 0), CONTRACT_CHANGE_DATE DESC) PHONE_NUMBER_CITY,
  FIRST_VALUE(PHONE_NUMBER_TYPE) OVER (PARTITION BY CONTRACT_ID ORDER BY DECODE(PHONE_NUMBER_TYPE, NULL, 1, 0), CONTRACT_CHANGE_DATE DESC) PHONE_NUMBER_TYPE,
  FIRST_VALUE(CONTRACT_CHANGE_DATE) OVER (PARTITION BY CONTRACT_ID ORDER BY DECODE(CONTRACT_CHANGE_DATE, NULL, 1, 0), CONTRACT_CHANGE_DATE DESC) CONTRACT_CHANGE_DATE,
  FIRST_VALUE(TARIFF_ID) OVER (PARTITION BY CONTRACT_ID ORDER BY DECODE(TARIFF_ID, NULL, 1, 0), CONTRACT_CHANGE_DATE DESC) TARIFF_ID,
  FIRST_VALUE(OPERATOR_ID) OVER (PARTITION BY CONTRACT_ID ORDER BY DECODE(OPERATOR_ID, NULL, 1, 0), CONTRACT_CHANGE_DATE DESC) OPERATOR_ID,
  CONTRACT_ID
  --SERVICE_ID, DISCONNECT_LIMIT, CONFIRMED, ABONENT_ID
FROM CONTRACT_CHANGES
) T
GROUP BY CONTRACT_ID;


CREATE OR REPLACE TRIGGER "BIN$+9V5/qVoSQClcWMHj76raA==$0"
  BEFORE INSERT OR UPDATE ON BIN$jVMY3xFvTDKHHeYdamAf6Q==$0 FOR EACH ROW
--#Version=1
BEGIN
  IF INSERTING THEN
    IF NVL(:NEW.DOCUM_TYPE_ID, 0) = 0 then
      :NEW.DOCUM_TYPE_ID := NEW_DOCUM_TYPE_ID;
    END IF;
    :NEW.USER_CREATED := USER;
    :NEW.DATE_CREATED := SYSDATE;
  END IF;
  :NEW.USER_LAST_UPDATED := USER;
  :NEW.DATE_LAST_UPDATED := SYSDATE;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TIU_DOCUM_TYPES
  BEFORE INSERT OR UPDATE ON DOCUM_TYPES FOR EACH ROW
--#Version=1
BEGIN
  IF INSERTING THEN
    IF NVL(:NEW.DOCUM_TYPE_ID, 0) = 0 then
      :NEW.DOCUM_TYPE_ID := NEW_DOCUM_TYPE_ID;
    END IF;
    :NEW.USER_CREATED := USER;
    :NEW.DATE_CREATED := SYSDATE;
  END IF;
  :NEW.USER_LAST_UPDATED := USER;
  :NEW.DATE_LAST_UPDATED := SYSDATE;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TIU_FILIALS
  BEFORE INSERT OR UPDATE ON FILIALS FOR EACH ROW
--#Version=1
BEGIN
  IF INSERTING THEN
    IF NVL(:NEW.FILIAL_ID, 0) = 0 then
      :NEW.FILIAL_ID := NEW_FILIAL_ID;
    END IF;
    :NEW.USER_CREATED := USER;
    :NEW.DATE_CREATED := SYSDATE;
  END IF;
  :NEW.USER_LAST_UPDATED := USER;
  :NEW.DATE_LAST_UPDATED := SYSDATE;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TIU_COUNTRIES
  BEFORE INSERT OR UPDATE ON COUNTRIES FOR EACH ROW
--#Version=1
BEGIN
  IF INSERTING THEN
    IF NVL(:NEW.COUNTRY_ID, 0) = 0 then
      :NEW.COUNTRY_ID := NEW_COUNTRY_ID;
    END IF;
    :NEW.USER_CREATED := USER;
    :NEW.DATE_CREATED := SYSDATE;
  END IF;
  :NEW.USER_LAST_UPDATED := USER;
  :NEW.DATE_LAST_UPDATED := SYSDATE;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TIU_REGIONS
  BEFORE INSERT OR UPDATE ON REGIONS FOR EACH ROW
--#Version=1
BEGIN
  IF INSERTING THEN
    IF NVL(:NEW.REGION_ID, 0) = 0 then
      :NEW.REGION_ID := NEW_REGION_ID;
    END IF;
    :NEW.USER_CREATED := USER;
    :NEW.DATE_CREATED := SYSDATE;
  END IF;
  :NEW.USER_LAST_UPDATED := USER;
  :NEW.DATE_LAST_UPDATED := SYSDATE;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TIU_OPERATORS
  BEFORE INSERT OR UPDATE ON OPERATORS FOR EACH ROW
--#Version=1
BEGIN
  IF INSERTING THEN
    IF NVL(:NEW.OPERATOR_ID, 0) = 0 then
      :NEW.OPERATOR_ID := NEW_OPERATOR_ID;
    END IF;
    :NEW.USER_CREATED := USER;
    :NEW.DATE_CREATED := SYSDATE;
  END IF;
  :NEW.USER_LAST_UPDATED := USER;
  :NEW.DATE_LAST_UPDATED := SYSDATE;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TIU_PHONE_BLOCKS
  BEFORE INSERT OR UPDATE ON PHONE_BLOCKS FOR EACH ROW
--#Version=1
BEGIN
  IF INSERTING THEN
    IF NVL(:NEW.PHONE_BLOCK_ID, 0) = 0 then
      :NEW.PHONE_BLOCK_ID := NEW_PHONE_BLOCK_ID;
    END IF;
    :NEW.USER_CREATED := USER;
    :NEW.DATE_CREATED := SYSDATE;
  END IF;
  :NEW.USER_LAST_UPDATED := USER;
  :NEW.DATE_LAST_UPDATED := SYSDATE;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER "BIN$VJxsmf6oRRugQNFAngYVJA==$0"
  BEFORE INSERT OR UPDATE ON BIN$FrqLQuoCTmuvCWsMQbmR0Q==$0 FOR EACH ROW
--#Version=1
BEGIN
  IF INSERTING THEN
    IF NVL(:NEW.SERVICE_ID, 0) = 0 then
      :NEW.SERVICE_ID := NEW_SERVICE_ID;
    END IF;
    :NEW.SERVICE_CREATED := USER;
    :NEW.DATE_CREATED := SYSDATE;
  END IF;
  :NEW.SERVICE_LAST_UPDATED := USER;
  :NEW.DATE_LAST_UPDATED := SYSDATE;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TIU_SERVICES
  BEFORE INSERT OR UPDATE ON SERVICES FOR EACH ROW
--#Version=1
BEGIN
  IF INSERTING THEN
    IF NVL(:NEW.SERVICE_ID, 0) = 0 then
      :NEW.SERVICE_ID := NEW_SERVICE_ID;
    END IF;
    :NEW.USER_CREATED := USER;
    :NEW.DATE_CREATED := SYSDATE;
  END IF;
  :NEW.USER_LAST_UPDATED := USER;
  :NEW.DATE_LAST_UPDATED := SYSDATE;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TIU_ABONENTS
  BEFORE INSERT OR UPDATE ON ABONENTS FOR EACH ROW
--#Version=1
BEGIN
  IF INSERTING THEN
    IF NVL(:NEW.ABONENT_ID, 0) = 0 then
      :NEW.ABONENT_ID := NEW_ABONENT_ID;
    END IF;
    :NEW.USER_CREATED := USER;
    :NEW.DATE_CREATED := SYSDATE;
  END IF;
  :NEW.USER_LAST_UPDATED := USER;
  :NEW.DATE_LAST_UPDATED := SYSDATE;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TIU_CONTRACT_CANCEL_TYPES
  BEFORE INSERT OR UPDATE ON CONTRACT_CANCEL_TYPES FOR EACH ROW
--#Version=1
BEGIN
  IF INSERTING THEN
    IF NVL(:NEW.CONTRACT_CANCEL_TYPE_ID, 0) = 0 then
      :NEW.CONTRACT_CANCEL_TYPE_ID := NEW_CONTRACT_CANCEL_TYPE_ID;
    END IF;
    :NEW.USER_CREATED := USER;
    :NEW.DATE_CREATED := SYSDATE;
  END IF;
  :NEW.USER_LAST_UPDATED := USER;
  :NEW.DATE_LAST_UPDATED := SYSDATE;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TIU_CONTRACT_CANCELS
  BEFORE INSERT OR UPDATE ON CONTRACT_CANCELS FOR EACH ROW
--#Version=1
BEGIN
  IF INSERTING THEN
    IF NVL(:NEW.CONTRACT_CANCEL_ID, 0) = 0 then
      :NEW.CONTRACT_CANCEL_ID := NEW_CONTRACT_CANCEL_ID;
    END IF;
    :NEW.USER_CREATED := USER;
    :NEW.DATE_CREATED := SYSDATE;
  END IF;
  :NEW.USER_LAST_UPDATED := USER;
  :NEW.DATE_LAST_UPDATED := SYSDATE;
END;
/
SHOW ERRORS;


CREATE OR REPLACE TRIGGER TIU_CONTRACT_CHANGES
  BEFORE INSERT OR UPDATE ON CONTRACT_CHANGES FOR EACH ROW
--#Version=1
BEGIN
  IF INSERTING THEN
    IF NVL(:NEW.CONTRACT_CHANGE_ID, 0) = 0 then
      :NEW.CONTRACT_CHANGE_ID := NEW_CONTRACT_CHANGE_ID;
    END IF;
    :NEW.USER_CREATED := USER;
    :NEW.DATE_CREATED := SYSDATE;
  END IF;
  :NEW.USER_LAST_UPDATED := USER;
  :NEW.DATE_LAST_UPDATED := SYSDATE;
END;
/
SHOW ERRORS;


ALTER TABLE OPERATORS ADD (
  CONSTRAINT PK_OPERATORS
 PRIMARY KEY
 (OPERATOR_ID));

ALTER TABLE COUNTRIES ADD (
  CONSTRAINT PK_COUNTRIES
 PRIMARY KEY
 (COUNTRY_ID));

ALTER TABLE REGIONS ADD (
  CONSTRAINT PK_REGIONS
 PRIMARY KEY
 (REGION_ID));

ALTER TABLE DOCUM_TYPES ADD (
  CONSTRAINT PK_DOCUM_TYPES
 PRIMARY KEY
 (DOCUM_TYPE_ID));

ALTER TABLE FILIALS ADD (
  CONSTRAINT PK_FILIALS
 PRIMARY KEY
 (FILIAL_ID));

ALTER TABLE PHONE_BLOCKS ADD (
  CONSTRAINT PK_PHONE_BLOCKS
 PRIMARY KEY
 (PHONE_BLOCK_ID));

ALTER TABLE SERVICES ADD (
  CONSTRAINT PK_SERVICES
 PRIMARY KEY
 (SERVICE_ID));

ALTER TABLE TARIFFS ADD (
  CONSTRAINT PK_TARIFFS
 PRIMARY KEY
 (TARIFF_ID));

ALTER TABLE ABONENTS ADD (
  CONSTRAINT PK_ABONENTS
 PRIMARY KEY
 (ABONENT_ID));

ALTER TABLE CONTRACT_CANCEL_TYPES ADD (
  CONSTRAINT PK_CONTRACT_CANCEL_TYPES
 PRIMARY KEY
 (CONTRACT_CANCEL_TYPE_ID));

ALTER TABLE CONTRACT_CANCELS ADD (
  CONSTRAINT PK_CONTRACT_CANCELS
 PRIMARY KEY
 (CONTRACT_CANCEL_ID));

ALTER TABLE CONTRACT_CHANGES ADD (
  CONSTRAINT PK_CONTRACT_CHANGES
 PRIMARY KEY
 (CONTRACT_CHANGE_ID));

ALTER TABLE AUTO_NUMERATION2_SEQUENCES ADD (
  CONSTRAINT PK_AUTO_NUMERATION2_SEQUENCES
 PRIMARY KEY
 (SEQUENCE_NAME));

ALTER TABLE REGIONS ADD (
  CONSTRAINT FK_REGIONS_COUNTRY_ID 
 FOREIGN KEY (COUNTRY_ID) 
 REFERENCES COUNTRIES (COUNTRY_ID));

ALTER TABLE PHONE_BLOCKS ADD (
  CONSTRAINT FK_PHONE_BLOCKS_OPERATOR_ID 
 FOREIGN KEY (OPERATOR_ID) 
 REFERENCES OPERATORS (OPERATOR_ID));

ALTER TABLE TARIFFS ADD (
  CONSTRAINT FK_TARIFFS_OPERATOR_ID 
 FOREIGN KEY (OPERATOR_ID) 
 REFERENCES OPERATORS (OPERATOR_ID));

ALTER TABLE ABONENTS ADD (
  CONSTRAINT FK_ABONENTS_CITIZENSHIP 
 FOREIGN KEY (CITIZENSHIP) 
 REFERENCES COUNTRIES (COUNTRY_ID),
  CONSTRAINT FK_ABONENTS_COUNTRY_ID 
 FOREIGN KEY (COUNTRY_ID) 
 REFERENCES COUNTRIES (COUNTRY_ID),
  CONSTRAINT FK_ABONENTS_REGION_ID 
 FOREIGN KEY (REGION_ID) 
 REFERENCES REGIONS (REGION_ID));

ALTER TABLE CONTRACT_CANCELS ADD (
  CONSTRAINT FK_CONTRACT_CANCELS_TARIFF_ID 
 FOREIGN KEY (CONTRACT_ID) 
 REFERENCES CONTRACTS (CONTRACT_ID),
  CONSTRAINT FK_CONTRACT_CANCELS_FILIAL_ID 
 FOREIGN KEY (FILIAL_ID) 
 REFERENCES FILIALS (FILIAL_ID),
  CONSTRAINT FK_CONTRACT_CANCELS_TYPE_ID 
 FOREIGN KEY (CONTRACT_CANCEL_TYPE_ID) 
 REFERENCES CONTRACT_CANCEL_TYPES (CONTRACT_CANCEL_TYPE_ID));

ALTER TABLE CONTRACT_CHANGES ADD (
  CONSTRAINT FK_CONTRACT_CHNGS_CONTRACT_ID 
 FOREIGN KEY (CONTRACT_ID) 
 REFERENCES CONTRACTS (CONTRACT_ID),
  CONSTRAINT FK_CONTRACT_CHANGES_FILIAL_ID 
 FOREIGN KEY (FILIAL_ID) 
 REFERENCES FILIALS (FILIAL_ID),
  CONSTRAINT FK_CONTRACT_CHNGS_OPERATOR_ID 
 FOREIGN KEY (OPERATOR_ID) 
 REFERENCES OPERATORS (OPERATOR_ID),
  CONSTRAINT FK_CONTRACT_CHANGES_TARIFF_ID 
 FOREIGN KEY (TARIFF_ID) 
 REFERENCES TARIFFS (TARIFF_ID),
  CONSTRAINT FK_CONTRACT_CHNGS_DOC_TYPE_ID 
 FOREIGN KEY (DOCUM_TYPE_ID) 
 REFERENCES DOCUM_TYPES (DOCUM_TYPE_ID));

ALTER TABLE TARIFFS ADD CONSTRAINT FK_CONTRACTS_PHONE_NUMBER_TYPE
  FOREIGN KEY (PHONE_NUMBER_TYPE) REFERENCES PHONE_NUMBER_TYPES;


