
  CREATE OR REPLACE FUNCTION "SIM_TRADE"."CALC_BALANCE_ROWS_TABLE_BY_DAY" (
  pPHONE_NUMBER IN VARCHAR2
  ) RETURN BALANCE_ROW_TAB PIPELINED AS
--#Version=1
--
-- Возвращает расшифровку баланса из CALC_BALANCE_ROWS2, но абонплату распределяет 
-- по дням, по одной строке на каждый день.
--
  vDATE_ROWS DBMS_SQL.DATE_TABLE;
  vCOST_ROWS DBMS_SQL.NUMBER_TABLE;
  vDESCRIPTION_ROWS DBMS_SQL.VARCHAR2_TABLE;
  I BINARY_INTEGER;
  cABONPAYMENT_PATTERN VARCHAR2(100 CHAR);
  vDESCRIPTION VARCHAR2(4000);
  vDESCRIPTION1 VARCHAR2(4000);
  vDESCRIPTION2 VARCHAR2(4000);
  BEGIN_DATE DATE;
  END_DATE DATE;
  COST NUMBER;
BEGIN
  cABONPAYMENT_PATTERN := '(.* Абонплата.*) [cс] (\d\d\.\d\d\.\d\d\d\d) по (\d\d\.\d\d\.\d\d\d\d)(.*)';
  CALC_BALANCE_ROWS2(pPHONE_NUMBER, vDATE_ROWS, vCOST_ROWS, vDESCRIPTION_ROWS);
  -- 
  I := vDATE_ROWS.FIRST;
  WHILE I IS NOT NULL LOOP
    vDESCRIPTION := vDESCRIPTION_ROWS(I);
    IF REGEXP_LIKE(vDESCRIPTION, cABONPAYMENT_PATTERN) THEN
    BEGIN_DATE := TO_DATE(REGEXP_REPLACE(vDESCRIPTION, cABONPAYMENT_PATTERN, '\2'), 'DD.MM.YYYY');
    END_DATE := TO_DATE(REGEXP_REPLACE(vDESCRIPTION, cABONPAYMENT_PATTERN, '\3'), 'DD.MM.YYYY');
    vDESCRIPTION1 := REGEXP_REPLACE(vDESCRIPTION, cABONPAYMENT_PATTERN, '\1');
    vDESCRIPTION2 := REGEXP_REPLACE(vDESCRIPTION, cABONPAYMENT_PATTERN, '\4');
    COST := vCOST_ROWS(I) / (END_DATE-BEGIN_DATE+1);
    WHILE BEGIN_DATE <= END_DATE LOOP
      PIPE ROW(
        BALANCE_ROW_TYPE(
          BEGIN_DATE,
          COST,
          vDESCRIPTION1 || ' за ' || TO_CHAR(BEGIN_DATE, 'DD.MM.YYYY') || vDESCRIPTION2
          )
        );
      BEGIN_DATE := BEGIN_DATE + 1;
    END LOOP;
  ELSE
    PIPE ROW(
      BALANCE_ROW_TYPE(
        vDATE_ROWS(I),
        vCOST_ROWS(I),
        vDESCRIPTION_ROWS(I)
        )
      );
    END IF;
    I := vDATE_ROWS.NEXT(I);
  END LOOP;
END;